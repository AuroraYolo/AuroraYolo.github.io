<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://codingheping.github.io</id>
    <title>codingheping</title>
    <updated>2020-11-10T09:09:46.070Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://codingheping.github.io"/>
    <link rel="self" href="https://codingheping.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://codingheping.github.io/images/avatar.png</logo>
    <icon>https://codingheping.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, codingheping</rights>
    <entry>
        <title type="html"><![CDATA[Mysql查询执行流程]]></title>
        <id>https://codingheping.github.io/post/mysql-cha-xun-zhi-xing-liu-cheng/</id>
        <link href="https://codingheping.github.io/post/mysql-cha-xun-zhi-xing-liu-cheng/">
        </link>
        <updated>2020-11-10T09:07:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="mysql-sql语句执行流程">MySQL SQL语句执行流程</h2>
<figure data-type="image" tabindex="1"><img src="https://codingheping.github.io/post-images/1604999295879.png" alt="" loading="lazy"></figure>
<p>大体来说,MySQL可以分为Server层和存储引擎层两部分.<br>
Server层包括连接器、查询缓存、分析器、优化器、执行器等,涵盖MySQL的大多数核心服务功能,以及<br>
所有的内置函数(如日期,时间,数学和加密函数),所有跨存储引擎的功能都在这一层实现,比如存储过程<br>
触发器、视图等.</p>
<p>存储引擎只负责数据的存储和提取.其架构模式是插件式的,支持InnoDB、MyiSAM、Memory<br>
等多个存储引擎,现在最常用的存储引擎是InnoDB.从MySQL5.5.5版本开始成为了默认引擎.</p>
<h3 id="连接器">连接器.</h3>
<p>第一步,先连接到数据库服务器上,这时候接待你的就是连接器.连接器负责跟客户端建立连接、获取权限、维持和管理连接.<br>
连接命令: mysql -h<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>p</mi><mo>−</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">ip -p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>port -u$user -p</p>
<h3 id="查询缓存">查询缓存</h3>
<p>连接建立完成后,就可以执行select语句了.执行逻辑来到第二步:查询缓存.</p>
<p>MySQL拿到一个查询请求后,会先到查询缓存查看,如果命中查询缓存就以key-value的形式返回.<br>
如果没有命中缓存,就进入下一个执行阶段.<br>
不建议开启缓存,MySQL8.0废弃了查询缓存.</p>
<h3 id="分析器">分析器</h3>
<p>没有命中查询缓存,开始执行语句,MySQL对SQL语句做解析.查看SQL语句是否满足MySQL语法,<br>
如果不满足就抛出错误.</p>
<h3 id="优化器">优化器</h3>
<p>经过了分析器,还要经过优化器.优化器是在表里有多个索引时,决定使用哪个索引;或者在一个语句中有多表<br>
关联(join),决定各个表的连接顺序.</p>
<h3 id="执行器">执行器</h3>
<p>开始执行的时候,判断一下对这个表有没有执行查询的权限,如果没有,就会返回没有权限的错误,如果有权限,就打开表<br>
继续执行。打开表的时候,执行器就会根据表的引擎定义,去使用(InnoDB,MyiSAM)引擎提供的接口.然后返回执行的结果.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql更新执行流程]]></title>
        <id>https://codingheping.github.io/post/mysql-geng-xin-zhi-xing-liu-cheng/</id>
        <link href="https://codingheping.github.io/post/mysql-geng-xin-zhi-xing-liu-cheng/">
        </link>
        <updated>2020-11-10T09:04:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="mysql-sql语句执行流程">MySQL SQL语句执行流程</h2>
<figure data-type="image" tabindex="1"><img src="https://codingheping.github.io/post-images/1604999136696.png" alt="" loading="lazy"></figure>
<p>与MySQL查询流程一样,更新流程还涉及两个重要的日志模块,redo log(重做日志)和binlog(归档日志).</p>
<h2 id="redo-log">redo log</h2>
<p>如果每一次的的更新操作都需要写进磁盘,然后磁盘也要找到对应的那条记录,然后再更新,整个IO成本、查找成本很高.MySQL里使用的是<br>
WAL技术,WAL的全称是Write-Ahead Logging.它的关键点是先写日志,再写磁盘.具体来说,当有一条记录需要更新的时候,InnoDB引擎就会先把记录写到redo log里面,<br>
并更新内存.这个时候更新就算完成了.同时,InnoDB引擎会在适当的时候,将这个操作记录更新到磁盘里面,而这个更新往往是在系统比较空闲的时候做.</p>
<p>InnoDB的redo log是固定大小的,比如可以配置为一组4个文件,每个文件的大小是1GB,那么总共可以记录4GB的操作.从头开始写,写到末尾就又回到开头循环写.如图所示:<br>
<img src="https://codingheping.github.io/post-images/1604999149606.png" alt="" loading="lazy"><br>
write pos是当前记录的位置,一边写一边往后移,写到第3号文件末尾后就回到0号文件开头.checkpoint是当前要擦除的位置,也是往后移并且循环的,擦除记录<br>
前要把记录更新到数据文件.<br>
有了redo log,InnoDB就可以保证即使数据库发送异常重启,之前提交的记录都不会丢失,这个能力成为crash-safe.</p>
<h2 id="bin-log">bin log</h2>
<p>redo log是InnoDB引擎特有的日志,而Server层也有自己的日志,称为binlog(归档日志).为什么有两份日志?因为最开始MySQL里并没有InnoDB引擎.<br>
MySQL自带的引擎是MyISAM,但是MyISAM没有crash-safe的能力,binlog日志只能用于归档.而InnoDB是另一个公司以插件形式引入MySQL的,既然只依靠binlog<br>
是没有crash-safe能力的,所以InnoDB使用redo log来实现crash-safe的能力.</p>
<h2 id="redo-log和bin-log的不同点">redo log和bin log的不同点</h2>
<p>1.redo log是InnoDB引擎特有的;bin log是MySQL的Server层实现的,所有引擎可以使用.<br>
2.redo log是物理日志,记录的是&quot;在某个数据页上做了什么修改&quot;;binlog是逻辑日志,记录的是这个语句的原始逻辑.比如&quot;给ID=2这一行的c字段加1&quot;.<br>
3.redo log是循环写的,空间固定会用完;binlog是可以追加写入的.&quot;追加写&quot;是指binlog文件写到一定大小后会切换到下一个.并不会覆盖一起的日志.</p>
<h2 id="innodb引擎执行更新语句时的内部流程">InnoDB引擎执行更新语句时的内部流程</h2>
<p>1.执行器先找到引擎取ID=2这一行.ID是主键,引擎直接用树搜索找到这一行.如果ID=2这一行所在的数据页本来就在内存中,就直接返回给执行器;否则,需要先从磁盘读入内存后再返回.<br>
2.执行器拿到引擎给的行数据,把这个值加上1,比如原来是N,现在是N+1,得到新的一行数据,再调用引擎接口写入这行新数据.<br>
3.引擎将这行数据更新到内存中,同时将这个更新操作记录到redo log里面,此时redo log处于prepare(预提交)状态.然后告知执行器执行完成了,随时可以提交事务.<br>
4.执行器生成这个操作的binlog,并把binlog写入磁盘.<br>
5.执行器调用引擎的提交事务交接口,引擎把刚刚写入的redo log改成提交(commit)状态,更新完成.将 redo log 的写入拆成了两个步骤：prepare和commit,这就是&quot;两阶段提交&quot;</p>
<h2 id="两阶段提交">两阶段提交</h2>
<p>为了让两份日志之间的逻辑一致.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql优化]]></title>
        <id>https://codingheping.github.io/post/mysql-you-hua/</id>
        <link href="https://codingheping.github.io/post/mysql-you-hua/">
        </link>
        <updated>2020-11-10T09:03:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常见误区">常见误区</h2>
<pre><code>1.通常来说把可为NULL的列改为NOT NULL不会对性能提升有多少帮助,只是如果计划在列上创建索引,就应该将该列设置为NOT NULL。
2.对整数类型指定宽度,比如INT(11)，没有任何卵用。INT使用32位（4个字节）存储空间，那么它的表示范围已经确定，所以INT(1)和INT(20)对于存储和计算是相同的。
3.UNSIGNED表示不允许负值，大致可以使正数的上限提高一倍。比如TINYINT存储范围是-128 ~ 127，而UNSIGNED TINYINT存储的范围却是0 - 255。
  
4.通常来讲，没有太大的必要使用DECIMAL数据类型。即使是在需要存储财务数据时，仍然可以使用BIGINT。比如需要精确到万分之一，那么可以将数据乘以一百万然后使用BIGINT存储。这样可以避免浮点数计算不准确和DECIMAL精确计算代价高的问题。
  
5.TIMESTAMP使用4个字节存储空间，DATETIME使用8个字节存储空间。因而，TIMESTAMP只能表示1970 - 2038年，比DATETIME表示的范围小得多，而且TIMESTAMP的值因时区不同而不同。
  
 6.大多数情况下没有使用枚举类型的必要，其中一个缺点是枚举的字符串列表是固定的，添加和删除字符串（枚举选项）必须使用ALTER TABLE（如果只只是在列表末尾追加元素，不需要重建表）。
  
 7.schema的列不要太多。原因是存储引擎的API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，这个转换过程的代价是非常高的。如果列太多而实际使用的列又很少的话，有可能会导致CPU占用过高。
  
 8.大表ALTER TABLE非常耗时，MySQL执行大部分修改表结果操作的方法是用新的结构创建一个张空表，从旧表中查出所有的数据插入新表，然后再删除旧表。尤其当内存不足而表又很大，而且还有很大索引的情况下，耗时更久。当然有一些奇技淫巧可以解决这个问题，有兴趣可自行查阅。
</code></pre>
<h2 id="总结建议">总结建议</h2>
<pre><code>1.数据库设计和表创建时要考虑性能.
2.sql的编写需要注意优化
3.分区
4.分表
5.分库
</code></pre>
<h2 id="数据库设计和表创建就要考虑性能">数据库设计和表创建就要考虑性能</h2>
<pre><code>1.表字段避免null出现,null值很难查询优化且占用额外的索引空间,推荐默认使用0代替null
2.尽量使用INT而非BIGINT,如果非负加上UNSIGNED,当然能使用TINYINT,SMALLINT,MEDIUM_INT更好.
3.使用枚举或整数代替字符串类型
4.尽量使用TIMESTAMP而非DATETIME
5.单表不要有太多字段
6.VARCHAR的长度只分配真正需要的空间
</code></pre>
<h2 id="索引">索引</h2>
<pre><code>1.根据查询有针对性的创建,考虑在WHERE和ORDER BY命令上涉及的列建立索引,可根据EXPLAIN来查看是否用了索引还是全表扫描.
2.应尽量避免在WHERE子句中对字段进行NULL值判断,否则导致引擎放弃使用索引而进行全表扫描.
3.值分布很稀少的字段不适合建索引,例如&quot;性别&quot;这种只有两三个值的字段.原因:非聚簇索引存储了对主键的引用，如果 select 字段不在非聚簇索引内，就需要跳到主键索引。
- 如果非聚簇索引值重复率高，那么查询时就会大量出现上图中从右边跳到左边的情况，导致整个流程很慢
数据库中聚集索引只有一个，默认主键。其他用户创建的索引都是非聚集索引。
非聚集索引存储了对主键的引用，即通过索引确定叶子节点之后，还需要再次根据主键去查询数据。（所以会查询两次）
如果非聚集索引重复率高（即一个同样的值有多个主键），那么首先你会从索引中取一半主键值，然后根据主键值再去查询数据，增加了IO，所以特别耗时。
4.字符字段只建前缀索引.
5.字符字段最好不要做主键.
6.不用外键,由程序保证约束.
7.尽量不要用UNIQUE,由程序保证约束.
</code></pre>
<h2 id="sql编写优化">sql编写优化.</h2>
<pre><code>1.使用limit对查询结果的记录进行限定.
2.避免select(*),将需要查找的字段列出来.
3.使用连接(join)来代替子查询
4.拆分大的delete或insert语句
5.可通过开启慢查询日志找出慢的SQL
6.OR改写成IN;OR的效率时N级别,IN的效率时log(n)级别,in的个数建议控制在200以内
7.避免使用%xxx查询.
8.使用同类型比较.123和123比
9.尽量避免在WHERE子句中使用!=或&lt;&gt;操作符,否则引擎放弃索引使用全表扫描
10.不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边；
11.对于联系数值,使用BETWEEN不要IN.SELECT id FROM t WHERE num BETWEEN 1 AND 5
12.列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大
13.sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库；
</code></pre>
<h2 id="引擎">引擎</h2>
<pre><code>MyISAM
MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：
1.不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁
2.不支持事务
3.不支持外键
4.不支持崩溃后的安全恢复
5.在表有读取查询的同时，支持往表中插入新纪录
6.支持BLOB和TEXT的前500个字符索引，支持全文索引
7.支持延迟更新索引，极大提升写入性能
8.对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用
</code></pre>
<pre><code> InnoDB
 InnoDB在MySQL 5.5后成为默认索引，它的特点是：
 1.支持行锁，采用MVCC来支持高并发
 2.支持事务
 3.支持外键
 4.支持崩溃后的安全恢复
 5.不支持全文索引总体来讲，MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JOIN]]></title>
        <id>https://codingheping.github.io/post/join/</id>
        <link href="https://codingheping.github.io/post/join/">
        </link>
        <updated>2020-11-10T08:58:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0-索引">0 索引</h1>
<pre><code>JOIN语句的执行顺序
INNER/LEFT/RIGHT/FULL JOIN的区别
ON和WHERE的区别
</code></pre>
<h1 id="1-概述">1 概述</h1>
<pre><code>一个完整的SQL语句中会被拆分成多个子句，子句的执行过程中会产生虚拟表(vt)，但是结果只返回最后一张虚拟表。从这个思路出发，我们试着理解一下JOIN查询的执行过程并解答一些常见的问题。
如果之前对不同JOIN的执行结果没有概念，可以结合这篇文章往下看
</code></pre>
<h1 id="2-join的执行顺序">2 JOIN的执行顺序</h1>
<pre><code>以下是JOIN查询的通用结构

SELECT &lt;row_list&gt; 
  FROM &lt;left_table&gt; 
    &lt;inner|left|right&gt; JOIN &lt;right_table&gt; 
      ON &lt;join condition&gt; 
        WHERE &lt;where_condition&gt;
它的执行顺序如下(SQL语句里第一个被执行的总是FROM子句)：

FROM:对左右两张表执行笛卡尔积，产生第一张表vt1。行数为n*m（n为左表的行数，m为右表的行数
ON:根据ON的条件逐行筛选vt1，将结果插入vt2中
JOIN:添加外部行，如果指定了LEFT JOIN(LEFT OUTER JOIN)，则先遍历一遍左表的每一行，其中不在vt2的行会被插入到vt2，该行的剩余字段将被填充为NULL，形成vt3；如果指定了RIGHT JOIN也是同理。但如果指定的是INNER JOIN，则不会添加外部行，上述插入过程被忽略，vt2=vt3（所以INNER JOIN的过滤条件放在ON或WHERE里 执行结果是没有区别的，下文会细说）

WHERE:对vt3进行条件过滤，满足条件的行被输出到vt4
SELECT:取出vt4的指定字段到vt5
下面用一个例子介绍一下上述联表的过程（这个例子不是个好的实践，只是为了说明join语法）
</code></pre>
<h1 id="3-举例">3 举例</h1>
<pre><code>创建一个用户信息表：

CREATE TABLE `user_info` (
  `userid` int(11) NOT NULL,
  `name` varchar(255) NOT NULL,
  UNIQUE `userid` (`userid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
再创建一个用户余额表：

CREATE TABLE `user_account` (
  `userid` int(11) NOT NULL,
  `money` bigint(20) NOT NULL,
 UNIQUE `userid` (`userid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
随便导入一些数据：

select * from user_info;
+--------+------+
| userid | name |
+--------+------+
|   1001 | x    |
|   1002 | y    |
|   1003 | z    |
|   1004 | a    |
|   1005 | b    |
|   1006 | c    |
|   1007 | d    |
|   1008 | e    |
+--------+------+
8 rows in set (0.00 sec)

select * from user_account;
+--------+-------+
| userid | money |
+--------+-------+
|   1001 |    22 |
|   1002 |    30 |
|   1003 |     8 |
|   1009 |    11 |
+--------+-------+
4 rows in set (0.00 sec)
一共8个用户有用户名，4个用户的账户有余额。
取出userid为1003的用户姓名和余额，SQL如下：

SELECT i.name, a.money 
  FROM user_info as i 
    LEFT JOIN user_account as a 
      ON i.userid = a.userid 
        WHERE a.userid = 1003;
第一步：执行FROM子句对两张表进行笛卡尔积操作
笛卡尔积操作后会返回两张表中所有行的组合，左表user_info有8行，右表user_account有4行，生成的虚拟表vt1就是8*4=32行：

SELECT * FROM user_info as i LEFT JOIN user_account as a ON 1;
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1001 |    22 |
|   1003 | z    |   1001 |    22 |
|   1004 | a    |   1001 |    22 |
|   1005 | b    |   1001 |    22 |
|   1006 | c    |   1001 |    22 |
|   1007 | d    |   1001 |    22 |
|   1008 | e    |   1001 |    22 |
|   1001 | x    |   1002 |    30 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1002 |    30 |
|   1004 | a    |   1002 |    30 |
|   1005 | b    |   1002 |    30 |
|   1006 | c    |   1002 |    30 |
|   1007 | d    |   1002 |    30 |
|   1008 | e    |   1002 |    30 |
|   1001 | x    |   1003 |     8 |
|   1002 | y    |   1003 |     8 |
|   1003 | z    |   1003 |     8 |
|   1004 | a    |   1003 |     8 |
|   1005 | b    |   1003 |     8 |
|   1006 | c    |   1003 |     8 |
|   1007 | d    |   1003 |     8 |
|   1008 | e    |   1003 |     8 |
|   1001 | x    |   1009 |    11 |
|   1002 | y    |   1009 |    11 |
|   1003 | z    |   1009 |    11 |
|   1004 | a    |   1009 |    11 |
|   1005 | b    |   1009 |    11 |
|   1006 | c    |   1009 |    11 |
|   1007 | d    |   1009 |    11 |
|   1008 | e    |   1009 |    11 |
+--------+------+--------+-------+
32 rows in set (0.00 sec)
第二步：执行ON子句过滤掉不满足条件的行
ON i.userid = a.userid 过滤之后vt2如下：

+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+
第三步：JOIN 添加外部行
LEFT JOIN会将左表未出现在vt2的行插入进vt2，每一行的剩余字段将被填充为NULL，RIGHT JOIN同理
本例中用的是LEFT JOIN，所以会将左表user_info剩下的行都添上 生成表vt3：

+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
|   1004 | a    |   NULL |  NULL |
|   1005 | b    |   NULL |  NULL |
|   1006 | c    |   NULL |  NULL |
|   1007 | d    |   NULL |  NULL |
|   1008 | e    |   NULL |  NULL |
+--------+------+--------+-------+
第四步：WHERE条件过滤
WHERE a.userid = 1003 生成表vt4：

+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+
第五步：SELECT
SELECT i.name, a.money 生成vt5：

+------+-------+
| name | money |
+------+-------+
| z    |     8 |
+------+-------+
虚拟表vt5作为最终结果返回给客户端

介绍完联表的过程之后，我们看看常用JOIN的区别

4 INNER/LEFT/RIGHT/FULL JOIN的区别
INNER JOIN...ON...: 返回 左右表互相匹配的所有行（因为只执行上文的第二步ON过滤，不执行第三步 添加外部行）
LEFT JOIN...ON...: 返回左表的所有行，若某些行在右表里没有相对应的匹配行，则将右表的列在新表中置为NULL
RIGHT JOIN...ON...: 返回右表的所有行，若某些行在左表里没有相对应的匹配行，则将左表的列在新表中置为NULL
INNER JOIN
拿上文的第三步添加外部行来举例，若LEFT JOIN替换成INNER JOIN，则会跳过这一步，生成的表vt3与vt2一模一样：

+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+
RIGHT JOIN
若LEFT JOIN替换成RIGHT JOIN，则生成的表vt3如下：

+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
|   NULL | NULL |   1009 |    11 |
+--------+------+--------+-------+
因为user_account（右表）里存在userid=1009这一行，而user_info（左表）里却找不到这一行的记录，所以会在第三步插入以下一行：

| NULL | NULL | 1009 | 11 |
FULL JOIN
上文引用的文章中提到了标准SQL定义的FULL JOIN，这在mysql里是不支持的，不过我们可以通过LEFT JOIN + UNION + RIGHT JOIN 来实现FULL JOIN：

SELECT * 
  FROM user_info as i 
    RIGHT JOIN user_account as a 
      ON a.userid=i.userid
union 
SELECT * 
  FROM user_info as i 
    LEFT JOIN user_account as a 
      ON a.userid=i.userid;
他会返回如下结果：

+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
|   NULL | NULL |   1009 |    11 |
|   1004 | a    |   NULL |  NULL |
|   1005 | b    |   NULL |  NULL |
|   1006 | c    |   NULL |  NULL |
|   1007 | d    |   NULL |  NULL |
|   1008 | e    |   NULL |  NULL |
+--------+------+--------+-------+
ps：其实我们从语义上就能看出LEFT JOIN和RIGHT JOIN没什么差别，两者的结果差异取决于左右表的放置顺序，以下内容摘自mysql官方文档：

RIGHT JOIN works analogously to LEFT JOIN. To keep code portable across databases, it is recommended that you use LEFT JOIN instead of RIGHT JOIN.
所以当你纠结使用LEFT JOIN还是RIGHT JOIN时，尽可能只使用LEFT JOIN吧

5 ON和WHERE的区别
上文把JOIN的执行顺序了解清楚之后，ON和WHERE的区别也就很好理解了。
举例说明:

SELECT * 
  FROM user_info as i
    LEFT JOIN user_account as a
      ON i.userid = a.userid and i.userid = 1003;
SELECT * 
  FROM user_info as i
    LEFT JOIN user_account as a
      ON i.userid = a.userid where i.userid = 1003;
第一种情况LEFT JOIN在执行完第二步ON子句后，筛选出满足i.userid = a.userid and i.userid = 1003的行，生成表vt2，然后执行第三步JOIN子句，将外部行添加进虚拟表生成vt3即最终结果：

vt2:
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+
vt3:
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   NULL |  NULL |
|   1002 | y    |   NULL |  NULL |
|   1003 | z    |   1003 |     8 |
|   1004 | a    |   NULL |  NULL |
|   1005 | b    |   NULL |  NULL |
|   1006 | c    |   NULL |  NULL |
|   1007 | d    |   NULL |  NULL |
|   1008 | e    |   NULL |  NULL |
+--------+------+--------+-------+
而第二种情况LEFT JOIN在执行完第二步ON子句后，筛选出满足i.userid = a.userid的行，生成表vt2；再执行第三步JOIN子句添加外部行生成表vt3；然后执行第四步WHERE子句，再对vt3表进行过滤生成vt4，得的最终结果：

vt2:
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+
vt3:
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
|   1004 | a    |   NULL |  NULL |
|   1005 | b    |   NULL |  NULL |
|   1006 | c    |   NULL |  NULL |
|   1007 | d    |   NULL |  NULL |
|   1008 | e    |   NULL |  NULL |
+--------+------+--------+-------+
vt4:
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+
如果将上例的LEFT JOIN替换成INNER JOIN，不论将条件过滤放到ON还是WHERE里，结果都是一样的，因为INNER JOIN不会执行第三步添加外部行

SELECT * 
  FROM user_info as i
    INNER JOIN user_account as a
      ON i.userid = a.userid and i.userid = 1003;
SELECT * 
  FROM user_info as i
    INNER JOIN user_account as a
      ON i.userid = a.userid where i.userid = 1003;
返回结果都是:

+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+
</code></pre>
<h1 id="四-建议">四 建议</h1>
<pre><code>1.使用 join 语句，性能比强行拆成多个单表执行 SQL 语句的性能要好
2.如果使用 join 语句的话，需要让小表做驱动表。
3.给被驱动表的关联字段加上索引
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CASE WHEN用法]]></title>
        <id>https://codingheping.github.io/post/case-when-yong-fa/</id>
        <link href="https://codingheping.github.io/post/case-when-yong-fa/">
        </link>
        <updated>2020-11-10T08:56:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mysql-的case-when-的语法">Mysql 的case when 的语法:</h1>
<p>1.简单函数</p>
<pre><code>CASE [col_name] WHEN [value1] THEN [result1]…ELSE [default] END
</code></pre>
<p>2.搜索函数</p>
<pre><code>CASE WHEN [expr] THEN [result1]…ELSE [default] END
</code></pre>
<h1 id="简单函数">简单函数</h1>
<pre><code>SELECT
	NAME '英雄',
	CASE NAME
		WHEN '德莱文' THEN
			'斧子'
		WHEN '德玛西亚-盖伦' THEN
			'大宝剑'
		WHEN '暗夜猎手-VN' THEN
			'弩'
		ELSE
			'无'
	END '装备'
FROM
	user_info;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5jc2RuLm5ldC8yMDE4MDMxOTE0MjgyMDM2NT93YXRlcm1hcmsvMi90ZXh0L0x5OWliRzluTG1OelpHNHVibVYwTDNGeFh6TXdNRE00TVRFeC9mb250LzVhNkw1TDJUL2ZvbnRzaXplLzQwMC9maWxsL0kwSkJRa0ZDTUE9PS9kaXNzb2x2ZS83MA?x-oss-process=image/format,png" alt="avatar" loading="lazy"></figure>
<h1 id="搜索函数">搜索函数</h1>
<pre><code>CASE WHEN [expr] THEN [result1]…ELSE [default] END：搜索函数可以写判断，并且搜索函数只会返回第一个符合条件的值，其他case被忽略
</code></pre>
<pre><code># when 表达式中可以使用 and 连接条件
SELECT
	NAME '英雄',
	age '年龄',
	CASE
		WHEN age &lt; 18 THEN
			'少年'
		WHEN age &lt; 30 THEN
			'青年'
		WHEN age &gt;= 30
		AND age &lt; 50 THEN
			'中年'
		ELSE
			'老年'
	END '状态'
FROM
	user_info;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5jc2RuLm5ldC8yMDE4MDMxOTE0MjkxMDkzP3dhdGVybWFyay8yL3RleHQvTHk5aWJHOW5MbU56Wkc0dWJtVjBMM0Z4WHpNd01ETTRNVEV4L2ZvbnQvNWE2TDVMMlQvZm9udHNpemUvNDAwL2ZpbGwvSTBKQlFrRkNNQT09L2Rpc3NvbHZlLzcw?x-oss-process=image/format,png" alt="avatar" loading="lazy"></figure>
<h1 id="聚合函数-sum-配合-case-when-的简单函数实现多表-left-join-的行转列">聚合函数 sum 配合 case when 的简单函数实现多表 left join 的行转列</h1>
<p>注：曾经有个爱学习的路人问我，“那个sum()只是为了好看一点吗？”，left join会以左表为主，连接右表时，得到所有匹配的数据，再group by时只会保留一行数据，因此case when时要借助sum函数，保留其他列的和。如果你还是不明白的话，那就亲手实践一下，只保留left join看一下结果，再group by，看一下结果。例如下面的案例：学生表/课程表/成绩表 ，三个表left join查询每个学生所有科目的成绩，使每个学生及其各科成绩一行展示。</p>
<pre><code>SELECT
	st.stu_id '学号',
	st.stu_name '姓名',
	sum(
		CASE co.course_name
		WHEN '大学语文' THEN
			sc.scores
		ELSE
			0
		END
	) '大学语文',
	sum(
		CASE co.course_name
		WHEN '新视野英语' THEN
			sc.scores
		ELSE
			0
		END
	) '新视野英语',
	sum(
		CASE co.course_name
		WHEN '离散数学' THEN
			sc.scores
		ELSE
			0
		END
	) '离散数学',
	sum(
		CASE co.course_name
		WHEN '概率论与数理统计' THEN
			sc.scores
		ELSE
			0
		END
	) '概率论与数理统计',
	sum(
		CASE co.course_name
		WHEN '线性代数' THEN
			sc.scores
		ELSE
			0
		END
	) '线性代数',
	sum(
		CASE co.course_name
		WHEN '高等数学' THEN
			sc.scores
		ELSE
			0
		END
	) '高等数学'
FROM
	edu_student st
LEFT JOIN edu_score sc ON st.stu_id = sc.stu_id
LEFT JOIN edu_courses co ON co.course_no = sc.course_no
GROUP BY
	st.stu_id
ORDER BY
	NULL;

</code></pre>
<figure data-type="image" tabindex="3"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5jc2RuLm5ldC8yMDE4MDMxOTE1MDg0MTkwNT93YXRlcm1hcmsvMi90ZXh0L0x5OWliRzluTG1OelpHNHVibVYwTDNGeFh6TXdNRE00TVRFeC9mb250LzVhNkw1TDJUL2ZvbnRzaXplLzQwMC9maWxsL0kwSkJRa0ZDTUE9PS9kaXNzb2x2ZS83MA?x-oss-process=image/format,png" alt="avatar" loading="lazy"></figure>
<h2 id="测试数据">测试数据</h2>
<pre><code>-- 创建表  学生表
CREATE TABLE `edu_student` (
	`stu_id` VARCHAR (16) NOT NULL COMMENT '学号',
	`stu_name` VARCHAR (20) NOT NULL COMMENT '学生姓名',
	PRIMARY KEY (`stu_id`)
) COMMENT = '学生表' ENGINE = INNODB;

-- 课程表 
CREATE TABLE `edu_courses` (
	`course_no` VARCHAR (20) NOT NULL COMMENT '课程编号',
	`course_name` VARCHAR (100) NOT NULL COMMENT '课程名称',
	PRIMARY KEY (`course_no`)
) COMMENT = '课程表' ENGINE = INNODB;

-- 成绩表
CREATE TABLE `edu_score` (
	`stu_id` VARCHAR (16) NOT NULL COMMENT '学号',
	`course_no` VARCHAR (20) NOT NULL COMMENT '课程编号',
	`scores` FLOAT NULL DEFAULT NULL COMMENT '得分',
	PRIMARY KEY (`stu_id`, `course_no`)
) COMMENT = '成绩表' ENGINE = INNODB;

-- 插入数据

-- 学生表数据

INSERT INTO edu_student (stu_id, stu_name)
VALUES
	('1001', '盲僧'),
	('1002', '赵信'),
	('1003', '皇子'),
	('1004', '寒冰'),
	('1005', '蛮王'),
	('1006', '狐狸');

-- 课程表数据 
INSERT INTO edu_courses (course_no, course_name)
VALUES
	('C001', '大学语文'),
	('C002', '新视野英语'),
	('C003', '离散数学'),
	(
		'C004',
		'概率论与数理统计'
	),
	('C005', '线性代数'),
	('C006', '高等数学');

-- 成绩表数据
INSERT INTO edu_score (stu_id, course_no, scores)
VALUES
	('1001', 'C001', 67),	('1002', 'C001', 68),	('1003', 'C001', 69),	('1004', 'C001', 70),	('1005', 'C001', 71),
	('1006', 'C001', 72),	('1001', 'C002', 87),	('1002', 'C002', 88),	('1003', 'C002', 89),	('1004', 'C002', 90),
	('1005', 'C002', 91),	('1006', 'C002', 92),	('1001', 'C003', 83),	('1002', 'C003', 84),	('1003', 'C003', 85),
	('1004', 'C003', 86),	('1005', 'C003', 87),	('1006', 'C003', 88),	('1001', 'C004', 88),	('1002', 'C004', 89),
	('1003', 'C004', 90),	('1004', 'C004', 91),	('1005', 'C004', 92),	('1006', 'C004', 93),	('1001', 'C005', 77),
	('1002', 'C005', 78),	('1003', 'C005', 79);

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue.socket-io连接hyperf.socket-io服务]]></title>
        <id>https://codingheping.github.io/post/vuesocket-io-lian-jie-hyperfsocket-io-fu-wu/</id>
        <link href="https://codingheping.github.io/post/vuesocket-io-lian-jie-hyperfsocket-io-fu-wu/">
        </link>
        <updated>2020-11-08T15:27:14.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://codingheping.github.io/post-images/1604849329083.jpg" alt="" loading="lazy"></figure>
<p>Last Edited By: he peter<br>
修改时间: Nov 8, 2020 11:25 PM<br>
创建人: he peter<br>
标签: sokcet.io,hyperf<br>
项目创建时间: Nov 8, 2020 11:16 PM</p>
<h2 id="1mainjs引入socket-io相关文件">1.main.js引入socket-io相关文件</h2>
<pre><code class="language-jsx">import VueSocketIO from 'vue-socket.io';

import SocketIO from 'socket.io-client';
</code></pre>
<h2 id="2初始化socket-io">2.初始化socket-io</h2>
<pre><code class="language-jsx">const token = `${getToken()}`

const socketInstance = SocketIO(process.env.WEB_SOCKET_URL, {
  transports: ['websocket','polling'],
  transportOptions: {
    polling: {
      extraHeaders: {
        Authorization: token
      }
    }
  },
  query:{
    token:token
  }
});

this.socket = new VueSocketIO({
  debug: true,
  connection: socketInstance
})
// Websocket 连接成功回调方法
this.socket.io.on('connect', () =&gt; {
  store.commit('UPDATE_SOCKET_STATUS', true);
})
// Websocket 断开连接回调方法
this.socket.io.on('disconnect', () =&gt; {
  store.commit('UPDATE_SOCKET_STATUS', false);
})
// Websocket 断开连接回调方法
this.socket.io.on('reconnect', () =&gt; {
  store.commit('UPDATE_SOCKET_STATUS', true);
})
Vue.use(this.socket)
</code></pre>
<h2 id="3组件中使用">3.组件中使用</h2>
<pre><code class="language-jsx">sockets: {
  // 三个默认方法
  // 链接成功
  connect () {
    console.log('socket connected')
  },
  // 链接失败
  disconnect () {
    console.log('socket disconnect')
  },
  // 重新连接
  reconnect () {
    console.log('socket reconnect')
  },
  // 第二种：监听、接收消息方法
  event (data) {
    console.log(data, 'TEAM_NOTICE，推送的消息')
  }
},
</code></pre>
<h2 id="4发送socket-io消息">4.发送socket-io消息</h2>
<pre><code class="language-jsx">mounted() {
  this.scrollEvent();
  // 第一种：监听，接收消息
  this.$socket.emit('event', {
    projectId: '88',
    theme: 'getUserInfo',
    time: 10000,
  });
},
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hyperf搭建socket-io服务]]></title>
        <id>https://codingheping.github.io/post/hyperf-da-jian-socket-io-fu-wu/</id>
        <link href="https://codingheping.github.io/post/hyperf-da-jian-socket-io-fu-wu/">
        </link>
        <updated>2020-11-04T15:37:22.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://codingheping.github.io/post-images/1604505686106.jpg" alt="" loading="lazy"><br>
Last Edited By: he peter<br>
修改时间: Nov 4, 2020 11:35 PM<br>
创建人: he peter<br>
标签: Hyperf<br>
项目创建时间: Nov 4, 2020 11:23 PM</p>
<h2 id="背景">背景</h2>
<p>自己一直想做一个分布式的IM,开始想的就是利用hyperf搭建个rpc服务做个消息代理,写了很久转过头来看了看hyperf的socket-io服务,发现他底层提供的RedisAdpater和RedisNsqAdpater提供处理分布式关系建立,然后利用redis的广播(pub,sub)或者NSQ建立一个Topic,每个socket服务单独建立一个channel，然后获取全部channel，给全部channel消费.</p>
<h3 id="1安装socket-io">1.安装socket-io</h3>
<pre><code class="language-bash">composer require hyperf/socketio-server
</code></pre>
<h2 id="2配置server">2.配置server</h2>
<pre><code class="language-php">// config/autoload/server.php
[
    'name' =&gt; 'socket-io',
    'type' =&gt; Server::SERVER_WEBSOCKET,
    'host' =&gt; '0.0.0.0',
    'port' =&gt; 9502,
    'sock_type' =&gt; SWOOLE_SOCK_TCP,
    'callbacks' =&gt; [
        SwooleEvent::ON_HAND_SHAKE =&gt; [Hyperf\WebSocketServer\Server::class, 'onHandShake'],
        SwooleEvent::ON_MESSAGE =&gt; [Hyperf\WebSocketServer\Server::class, 'onMessage'],
        SwooleEvent::ON_CLOSE =&gt; [Hyperf\WebSocketServer\Server::class, 'onClose'],
    ],
],
</code></pre>
<h3 id="3搭建服务端">3.搭建服务端</h3>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace App\Controller;

use Hyperf\SocketIOServer\Annotation\Event;
use Hyperf\SocketIOServer\Annotation\SocketIONamespace;
use Hyperf\SocketIOServer\BaseNamespace;
use Hyperf\SocketIOServer\Socket;
use Hyperf\Utils\Codec\Json;

/**
 * @SocketIONamespace(&quot;/&quot;)
 */
class WebSocketController extends BaseNamespace
{
    /**
     * @Event(&quot;event&quot;)
     * @param string $data
     */
    public function onEvent(Socket $socket, $data)
    {
        // 应答
        return 'Event Received: ' . $data;
    }

    /**
     * @Event(&quot;join-room&quot;)
     * @param string $data
     */
    public function onJoinRoom(Socket $socket, $data)
    {
        // 将当前用户加入房间
        $socket-&gt;join($data);
        // 向房间内其他用户推送（不含当前用户）
        $socket-&gt;to($data)-&gt;emit('event', $socket-&gt;getSid() . &quot;has joined {$data}&quot;);
        // 向房间内所有人广播（含当前用户）
        $this-&gt;emit('event', 'There are ' . count($socket-&gt;getAdapter()-&gt;clients($data)) . &quot; players in {$data}&quot;);
    }

    /**
     * @Event(&quot;say&quot;)
     * @param string $data
     */
    public function onSay(Socket $socket, $data)
    {
        $data = Json::decode($data);
        $socket-&gt;to($data['room'])-&gt;emit('event', $socket-&gt;getSid() . &quot; say: {$data['message']}&quot;);
    }
}

</code></pre>
<h2 id="4配置房间适配器利用redisnsqadapter处理分布式">4.配置房间适配器,利用RedisNsqAdapter处理分布式</h2>
<pre><code class="language-php">&lt;?php

declare(strict_types = 1);

/**
 * This file is part of Hyperf.
 *
 * @link     https://www.hyperf.io
 * @document https://hyperf.wiki
 * @contact  group@hyperf.io
 * @license  https://github.com/hyperf/hyperf/blob/master/LICENSE
 */

use Hyperf\SocketIOServer\Room\AdapterInterface;
use Hyperf\SocketIOServer\Room\RedisNsqAdapter;
use Hyperf\SocketIOServer\SocketIO;
use App\Kernel\SocketIO as KernelSocketIO;
use Hyperf\JsonRpc\JsonRpcPoolTransporter;
use Hyperf\JsonRpc\JsonRpcTransporter;
use Hyperf\Utils\Serializer\SerializerFactory;
use Hyperf\Utils\Serializer\Serializer;

return [
    AdapterInterface::class                    =&gt; RedisNsqAdapter::class,
    SocketIO::class                            =&gt; KernelSocketIO::class,
    JsonRpcTransporter::class                  =&gt; JsonRpcPoolTransporter::class,
    Hyperf\Contract\NormalizerInterface::class =&gt; new SerializerFactory(Serializer::class),
];
</code></pre>
<h2 id="5重写socket-io主要用于用户上线通知下线通知">5.重写socket-io(主要用于用户上线通知,下线通知)</h2>
<pre><code class="language-php">&lt;?php
declare(strict_types = 1);

namespace App\Kernel;

use App\JsonRpc\Contract\InterfaceUserService;
use App\Log;
use Hyperf\Redis\RedisFactory;
use Hyperf\WebSocketServer\Context as WsContext;
use Phper666\JWTAuth\Exception\TokenValidException;
use Swoole\Http\Request;
use Hyperf\Di\Annotation\Inject;

class SocketIO extends \Hyperf\SocketIOServer\SocketIO
{
    protected $pingTimeout = 2000;

    protected $pingInterval = 10000; //心跳间隔6秒

    protected $clientCallbackTimeout = 2000;

    public const HASH_UID_TO_FD_PREFIX = 'hash.socket_user';

    /**
     * @Inject
     * @var \Phper666\JWTAuth\JWT
     */
    protected $jwt;

    /**
     * @Inject()
     * @var \App\Service\UserService
     */
    protected $userService;

    /**
     * @Inject()
     * @var \App\Service\UserFriendService
     */
    protected $userFriendService;

    /**
     * @param \Swoole\Http\Response|\Swoole\WebSocket\Server $server
     * @param \Swoole\Http\Request                           $request
     *
     * @throws \Throwable
     */
    public function onOpen($server, Request $request) : void
    {
        try {
            $isValidToken = false;
            $token        = $request-&gt;get['token'] ?? '';
            if (strlen($token) &gt; 0) {
                if (di(InterfaceUserService::class)-&gt;checkToken($token)) {
                    $isValidToken = true;
                }
            }
            if (!$isValidToken) {
                throw new TokenValidException('Token authentication does not pass', 401);
            }
        } catch (\Throwable $throwable) {
            $this-&gt;stdoutLogger-&gt;error(sprintf('[%s] [%s]', $throwable-&gt;getMessage(), $throwable-&gt;getCode()));
            $server-&gt;close($request-&gt;fd);
            return;
        }

        $userData = di(InterfaceUserService::class)-&gt;decodeToken($token);
        $uid      = $userData['cloud_uid'] ?? 0;
        $rpcUser  = di(InterfaceUserService::class);
        $user     = $rpcUser-&gt;get($uid);
        //TODO 建立json-rpc客户端获取用户详细信息
        WsContext::set('user', array_merge(
            ['user' =&gt; $user],
            ['sid' =&gt; $this-&gt;sidProvider-&gt;getSid($request-&gt;fd)]));
        //判断用户是否在其它地方登录
        $redis    = di(RedisFactory::class)-&gt;get(env('CLOUD_REDIS'));
        $isOnline = $sid = $redis-&gt;hGet(self::HASH_UID_TO_FD_PREFIX, (string)$uid);
        $redis-&gt;multi();
        if ($sid) {
            //解除之前的关系
            $redis-&gt;hDel(self::HASH_UID_TO_FD_PREFIX, (string)$uid);
            $this-&gt;to($sid)-&gt;emit('leave', '您的账号在其他地方登录,请注意是否是账号信息被泄漏,请及时更改密码!');
        }
        unset($sid);
        $sid = $this-&gt;sidProvider-&gt;getSid($request-&gt;fd);
        // 绑定用户与fd该功能
        $redis-&gt;hSet(self::HASH_UID_TO_FD_PREFIX, (string)$uid, $sid);
        $redis-&gt;exec();

        // 绑定聊天群
        $groups = $this-&gt;userService-&gt;getUserGroupIds($uid);
        if ($groups) {
            foreach ($groups as $group) {
                $this-&gt;getAdapter()-&gt;add(
                    $this-&gt;sidProvider-&gt;getSid($request-&gt;fd),
                    'room' . (string)$group);
            }
        }
        if (!$isOnline) {
            //获取所有好友的用户ID
            $uids       = $this-&gt;userFriendService-&gt;getFriends($uid);
            $friendSids = [];//所有好友的客户端socketid(sid)
            foreach ($uids as $friend) {
                $friendSids = array_push($friendSids, $redis-&gt;hGet(self::HASH_UID_TO_FD_PREFIX, (string)$friend));
            }
            //推送好友上线通知
            if ($friendSids) {
                $this-&gt;to($sid)-&gt;emit('login_notify', $friendSids, ['user_id' =&gt; $uid, 'status' =&gt; 1, 'notify' =&gt; '好友上线通知...']);
            }
        }
        // 绑定聊天群
        parent::onOpen($server, $request);
    }

    /**
     * @param \Swoole\Http\Response|\Swoole\Server $server
     * @param int                                  $fd
     * @param int                                  $reactorId
     *
     * @throws \Throwable
     */
    public function onClose($server, int $fd, int $reactorId) : void
    {
        /**
         * @var array $user
         */
        $user = WsContext::get('user');
        // 获取客户端对应的用户ID
        // 清除用户绑定信息
        $redis = di(RedisFactory::class)-&gt;get(env('CLOUD_REDIS'));
        $redis-&gt;hDel(self::HASH_UID_TO_FD_PREFIX, (string)$user['user']['id']);
        // 将fd 退出所有聊天室
        $this-&gt;getAdapter()-&gt;del($user['sid']);
        WsContext::destroy('user');
        //获取所有好友的用户ID
        $uids       = $this-&gt;userFriendService-&gt;getFriends($user['user']['id']);
        $friendSids = [];//所有好友的客户端socketid(sid)
        foreach ($uids as $friend) {
            $friendSids = array_push($friendSids, $redis-&gt;hGet(self::HASH_UID_TO_FD_PREFIX, (string)$friend));
        }
        //推送好友下线通知
        if ($friendSids) {
            $this-&gt;to($user['sid'])-&gt;emit('login_notify', $friendSids, [
                'user_id' =&gt; $user['id'],
                'status'  =&gt; 0,
                'notify'  =&gt; '好友离线通知...'
            ]);
        }
        // 判断用户是否多平台登录
        parent::onClose($server, $fd, $reactorId);
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用redis存储websocket或tcp的fd功能和聊天室内的fd]]></title>
        <id>https://codingheping.github.io/post/li-yong-redis-cun-chu-websocket-huo-tcp-de-fd-gong-neng-he-liao-tian-shi-nei-de-fd/</id>
        <link href="https://codingheping.github.io/post/li-yong-redis-cun-chu-websocket-huo-tcp-de-fd-gong-neng-he-liao-tian-shi-nei-de-fd/">
        </link>
        <updated>2020-11-04T09:33:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="利用redis存储websocket或tcp的fd功能和聊天室内的fd">利用redis存储websocket或tcp的fd功能和聊天室内的fd</h1>
<p>Last Edited By: he peter<br>
修改时间: Nov 4, 2020 5:31 PM<br>
创建人: he peter<br>
标签: websocket<br>
项目创建时间: Oct 21, 2020 10:08 AM</p>
<h1 id="利用redis的hash类型存储fd">利用redis的hash类型存储fd</h1>
<pre><code class="language-php">$redis = di(RedisFactory::class)-&gt;get(env('CLOUD_REDIS'));
//bind key to fd
$redis-&gt;hSet(self::HASH_KEY_TO_FD_PREFIX, $key, $fd);
</code></pre>
<h1 id="利用set无序集合存储聊天室内的fd">利用set无序集合存储聊天室内的fd</h1>
<pre><code class="language-php">//add fd to room
$redis-&gt;sAdd(sprintf('%s.%s', self::SET_ROOM_FD_PREFIX, $roomId), $fd);
</code></pre>
]]></content>
    </entry>
</feed>