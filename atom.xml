<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://codingheping.github.io</id>
    <title>codingheping</title>
    <updated>2020-11-04T15:42:12.838Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://codingheping.github.io"/>
    <link rel="self" href="https://codingheping.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://codingheping.github.io/images/avatar.png</logo>
    <icon>https://codingheping.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, codingheping</rights>
    <entry>
        <title type="html"><![CDATA[Hyperf搭建socket-io服务]]></title>
        <id>https://codingheping.github.io/post/hyperf-da-jian-socket-io-fu-wu/</id>
        <link href="https://codingheping.github.io/post/hyperf-da-jian-socket-io-fu-wu/">
        </link>
        <updated>2020-11-04T15:37:22.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://codingheping.github.io/post-images/1604504525354.jpg" alt="" loading="lazy"></figure>
<p>Last Edited By: he peter<br>
修改时间: Nov 4, 2020 11:35 PM<br>
创建人: he peter<br>
标签: Hyperf<br>
项目创建时间: Nov 4, 2020 11:23 PM</p>
<h2 id="背景">背景</h2>
<p>自己一直想做一个分布式的IM,开始想的就是利用hyperf搭建个rpc服务做个消息代理,写了很久转过头来看了看hyperf的socket-io服务,发现他底层提供的RedisAdpater和RedisNsqAdpater提供处理分布式关系建立,然后利用redis的广播(pub,sub)或者NSQ建立一个Topic,每个socket服务单独建立一个channel，然后获取全部channel，给全部channel消费.</p>
<h3 id="1安装socket-io">1.安装socket-io</h3>
<pre><code class="language-bash">composer require hyperf/socketio-server
</code></pre>
<h2 id="2配置server">2.配置server</h2>
<pre><code class="language-php">// config/autoload/server.php
[
    'name' =&gt; 'socket-io',
    'type' =&gt; Server::SERVER_WEBSOCKET,
    'host' =&gt; '0.0.0.0',
    'port' =&gt; 9502,
    'sock_type' =&gt; SWOOLE_SOCK_TCP,
    'callbacks' =&gt; [
        SwooleEvent::ON_HAND_SHAKE =&gt; [Hyperf\WebSocketServer\Server::class, 'onHandShake'],
        SwooleEvent::ON_MESSAGE =&gt; [Hyperf\WebSocketServer\Server::class, 'onMessage'],
        SwooleEvent::ON_CLOSE =&gt; [Hyperf\WebSocketServer\Server::class, 'onClose'],
    ],
],
</code></pre>
<h3 id="3搭建服务端">3.搭建服务端</h3>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace App\Controller;

use Hyperf\SocketIOServer\Annotation\Event;
use Hyperf\SocketIOServer\Annotation\SocketIONamespace;
use Hyperf\SocketIOServer\BaseNamespace;
use Hyperf\SocketIOServer\Socket;
use Hyperf\Utils\Codec\Json;

/**
 * @SocketIONamespace(&quot;/&quot;)
 */
class WebSocketController extends BaseNamespace
{
    /**
     * @Event(&quot;event&quot;)
     * @param string $data
     */
    public function onEvent(Socket $socket, $data)
    {
        // 应答
        return 'Event Received: ' . $data;
    }

    /**
     * @Event(&quot;join-room&quot;)
     * @param string $data
     */
    public function onJoinRoom(Socket $socket, $data)
    {
        // 将当前用户加入房间
        $socket-&gt;join($data);
        // 向房间内其他用户推送（不含当前用户）
        $socket-&gt;to($data)-&gt;emit('event', $socket-&gt;getSid() . &quot;has joined {$data}&quot;);
        // 向房间内所有人广播（含当前用户）
        $this-&gt;emit('event', 'There are ' . count($socket-&gt;getAdapter()-&gt;clients($data)) . &quot; players in {$data}&quot;);
    }

    /**
     * @Event(&quot;say&quot;)
     * @param string $data
     */
    public function onSay(Socket $socket, $data)
    {
        $data = Json::decode($data);
        $socket-&gt;to($data['room'])-&gt;emit('event', $socket-&gt;getSid() . &quot; say: {$data['message']}&quot;);
    }
}

</code></pre>
<h2 id="4配置房间适配器利用redisnsqadapter处理分布式">4.配置房间适配器,利用RedisNsqAdapter处理分布式</h2>
<pre><code class="language-php">&lt;?php

declare(strict_types = 1);

/**
 * This file is part of Hyperf.
 *
 * @link     https://www.hyperf.io
 * @document https://hyperf.wiki
 * @contact  group@hyperf.io
 * @license  https://github.com/hyperf/hyperf/blob/master/LICENSE
 */

use Hyperf\SocketIOServer\Room\AdapterInterface;
use Hyperf\SocketIOServer\Room\RedisNsqAdapter;
use Hyperf\SocketIOServer\SocketIO;
use App\Kernel\SocketIO as KernelSocketIO;
use Hyperf\JsonRpc\JsonRpcPoolTransporter;
use Hyperf\JsonRpc\JsonRpcTransporter;
use Hyperf\Utils\Serializer\SerializerFactory;
use Hyperf\Utils\Serializer\Serializer;

return [
    AdapterInterface::class                    =&gt; RedisNsqAdapter::class,
    SocketIO::class                            =&gt; KernelSocketIO::class,
    JsonRpcTransporter::class                  =&gt; JsonRpcPoolTransporter::class,
    Hyperf\Contract\NormalizerInterface::class =&gt; new SerializerFactory(Serializer::class),
];
</code></pre>
<h2 id="5重写socket-io主要用于用户上线通知下线通知">5.重写socket-io(主要用于用户上线通知,下线通知)</h2>
<pre><code class="language-php">&lt;?php
declare(strict_types = 1);

namespace App\Kernel;

use App\JsonRpc\Contract\InterfaceUserService;
use App\Log;
use Hyperf\Redis\RedisFactory;
use Hyperf\WebSocketServer\Context as WsContext;
use Phper666\JWTAuth\Exception\TokenValidException;
use Swoole\Http\Request;
use Hyperf\Di\Annotation\Inject;

class SocketIO extends \Hyperf\SocketIOServer\SocketIO
{
    protected $pingTimeout = 2000;

    protected $pingInterval = 10000; //心跳间隔6秒

    protected $clientCallbackTimeout = 2000;

    public const HASH_UID_TO_FD_PREFIX = 'hash.socket_user';

    /**
     * @Inject
     * @var \Phper666\JWTAuth\JWT
     */
    protected $jwt;

    /**
     * @Inject()
     * @var \App\Service\UserService
     */
    protected $userService;

    /**
     * @Inject()
     * @var \App\Service\UserFriendService
     */
    protected $userFriendService;

    /**
     * @param \Swoole\Http\Response|\Swoole\WebSocket\Server $server
     * @param \Swoole\Http\Request                           $request
     *
     * @throws \Throwable
     */
    public function onOpen($server, Request $request) : void
    {
        try {
            $isValidToken = false;
            $token        = $request-&gt;get['token'] ?? '';
            if (strlen($token) &gt; 0) {
                if (di(InterfaceUserService::class)-&gt;checkToken($token)) {
                    $isValidToken = true;
                }
            }
            if (!$isValidToken) {
                throw new TokenValidException('Token authentication does not pass', 401);
            }
        } catch (\Throwable $throwable) {
            $this-&gt;stdoutLogger-&gt;error(sprintf('[%s] [%s]', $throwable-&gt;getMessage(), $throwable-&gt;getCode()));
            $server-&gt;close($request-&gt;fd);
            return;
        }

        $userData = di(InterfaceUserService::class)-&gt;decodeToken($token);
        $uid      = $userData['cloud_uid'] ?? 0;
        $rpcUser  = di(InterfaceUserService::class);
        $user     = $rpcUser-&gt;get($uid);
        //TODO 建立json-rpc客户端获取用户详细信息
        WsContext::set('user', array_merge(
            ['user' =&gt; $user],
            ['sid' =&gt; $this-&gt;sidProvider-&gt;getSid($request-&gt;fd)]));
        //判断用户是否在其它地方登录
        $redis    = di(RedisFactory::class)-&gt;get(env('CLOUD_REDIS'));
        $isOnline = $sid = $redis-&gt;hGet(self::HASH_UID_TO_FD_PREFIX, (string)$uid);
        $redis-&gt;multi();
        if ($sid) {
            //解除之前的关系
            $redis-&gt;hDel(self::HASH_UID_TO_FD_PREFIX, (string)$uid);
            $this-&gt;to($sid)-&gt;emit('leave', '您的账号在其他地方登录,请注意是否是账号信息被泄漏,请及时更改密码!');
        }
        unset($sid);
        $sid = $this-&gt;sidProvider-&gt;getSid($request-&gt;fd);
        // 绑定用户与fd该功能
        $redis-&gt;hSet(self::HASH_UID_TO_FD_PREFIX, (string)$uid, $sid);
        $redis-&gt;exec();

        // 绑定聊天群
        $groups = $this-&gt;userService-&gt;getUserGroupIds($uid);
        if ($groups) {
            foreach ($groups as $group) {
                $this-&gt;getAdapter()-&gt;add(
                    $this-&gt;sidProvider-&gt;getSid($request-&gt;fd),
                    'room' . (string)$group);
            }
        }
        if (!$isOnline) {
            //获取所有好友的用户ID
            $uids       = $this-&gt;userFriendService-&gt;getFriends($uid);
            $friendSids = [];//所有好友的客户端socketid(sid)
            foreach ($uids as $friend) {
                $friendSids = array_push($friendSids, $redis-&gt;hGet(self::HASH_UID_TO_FD_PREFIX, (string)$friend));
            }
            //推送好友上线通知
            if ($friendSids) {
                $this-&gt;to($sid)-&gt;emit('login_notify', $friendSids, ['user_id' =&gt; $uid, 'status' =&gt; 1, 'notify' =&gt; '好友上线通知...']);
            }
        }
        // 绑定聊天群
        parent::onOpen($server, $request);
    }

    /**
     * @param \Swoole\Http\Response|\Swoole\Server $server
     * @param int                                  $fd
     * @param int                                  $reactorId
     *
     * @throws \Throwable
     */
    public function onClose($server, int $fd, int $reactorId) : void
    {
        /**
         * @var array $user
         */
        $user = WsContext::get('user');
        // 获取客户端对应的用户ID
        // 清除用户绑定信息
        $redis = di(RedisFactory::class)-&gt;get(env('CLOUD_REDIS'));
        $redis-&gt;hDel(self::HASH_UID_TO_FD_PREFIX, (string)$user['user']['id']);
        // 将fd 退出所有聊天室
        $this-&gt;getAdapter()-&gt;del($user['sid']);
        WsContext::destroy('user');
        //获取所有好友的用户ID
        $uids       = $this-&gt;userFriendService-&gt;getFriends($user['user']['id']);
        $friendSids = [];//所有好友的客户端socketid(sid)
        foreach ($uids as $friend) {
            $friendSids = array_push($friendSids, $redis-&gt;hGet(self::HASH_UID_TO_FD_PREFIX, (string)$friend));
        }
        //推送好友下线通知
        if ($friendSids) {
            $this-&gt;to($user['sid'])-&gt;emit('login_notify', $friendSids, [
                'user_id' =&gt; $user['id'],
                'status'  =&gt; 0,
                'notify'  =&gt; '好友离线通知...'
            ]);
        }
        // 判断用户是否多平台登录
        parent::onClose($server, $fd, $reactorId);
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用redis存储websocket或tcp的fd功能和聊天室内的fd]]></title>
        <id>https://codingheping.github.io/post/li-yong-redis-cun-chu-websocket-huo-tcp-de-fd-gong-neng-he-liao-tian-shi-nei-de-fd/</id>
        <link href="https://codingheping.github.io/post/li-yong-redis-cun-chu-websocket-huo-tcp-de-fd-gong-neng-he-liao-tian-shi-nei-de-fd/">
        </link>
        <updated>2020-11-04T09:33:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="利用redis存储websocket或tcp的fd功能和聊天室内的fd">利用redis存储websocket或tcp的fd功能和聊天室内的fd</h1>
<p>Last Edited By: he peter<br>
修改时间: Nov 4, 2020 5:31 PM<br>
创建人: he peter<br>
标签: websocket<br>
项目创建时间: Oct 21, 2020 10:08 AM</p>
<h1 id="利用redis的hash类型存储fd">利用redis的hash类型存储fd</h1>
<pre><code class="language-php">$redis = di(RedisFactory::class)-&gt;get(env('CLOUD_REDIS'));
//bind key to fd
$redis-&gt;hSet(self::HASH_KEY_TO_FD_PREFIX, $key, $fd);
</code></pre>
<h1 id="利用set无序集合存储聊天室内的fd">利用set无序集合存储聊天室内的fd</h1>
<pre><code class="language-php">//add fd to room
$redis-&gt;sAdd(sprintf('%s.%s', self::SET_ROOM_FD_PREFIX, $roomId), $fd);
</code></pre>
]]></content>
    </entry>
</feed>