<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://codingheping.github.io</id>
    <title>codingheping</title>
    <updated>2020-11-10T09:01:31.688Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://codingheping.github.io"/>
    <link rel="self" href="https://codingheping.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://codingheping.github.io/images/avatar.png</logo>
    <icon>https://codingheping.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, codingheping</rights>
    <entry>
        <title type="html"><![CDATA[JOIN]]></title>
        <id>https://codingheping.github.io/post/join/</id>
        <link href="https://codingheping.github.io/post/join/">
        </link>
        <updated>2020-11-10T08:58:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0-索引">0 索引</h1>
<pre><code>JOIN语句的执行顺序
INNER/LEFT/RIGHT/FULL JOIN的区别
ON和WHERE的区别
</code></pre>
<h1 id="1-概述">1 概述</h1>
<pre><code>一个完整的SQL语句中会被拆分成多个子句，子句的执行过程中会产生虚拟表(vt)，但是结果只返回最后一张虚拟表。从这个思路出发，我们试着理解一下JOIN查询的执行过程并解答一些常见的问题。
如果之前对不同JOIN的执行结果没有概念，可以结合这篇文章往下看
</code></pre>
<h1 id="2-join的执行顺序">2 JOIN的执行顺序</h1>
<pre><code>以下是JOIN查询的通用结构

SELECT &lt;row_list&gt; 
  FROM &lt;left_table&gt; 
    &lt;inner|left|right&gt; JOIN &lt;right_table&gt; 
      ON &lt;join condition&gt; 
        WHERE &lt;where_condition&gt;
它的执行顺序如下(SQL语句里第一个被执行的总是FROM子句)：

FROM:对左右两张表执行笛卡尔积，产生第一张表vt1。行数为n*m（n为左表的行数，m为右表的行数
ON:根据ON的条件逐行筛选vt1，将结果插入vt2中
JOIN:添加外部行，如果指定了LEFT JOIN(LEFT OUTER JOIN)，则先遍历一遍左表的每一行，其中不在vt2的行会被插入到vt2，该行的剩余字段将被填充为NULL，形成vt3；如果指定了RIGHT JOIN也是同理。但如果指定的是INNER JOIN，则不会添加外部行，上述插入过程被忽略，vt2=vt3（所以INNER JOIN的过滤条件放在ON或WHERE里 执行结果是没有区别的，下文会细说）

WHERE:对vt3进行条件过滤，满足条件的行被输出到vt4
SELECT:取出vt4的指定字段到vt5
下面用一个例子介绍一下上述联表的过程（这个例子不是个好的实践，只是为了说明join语法）
</code></pre>
<h1 id="3-举例">3 举例</h1>
<pre><code>创建一个用户信息表：

CREATE TABLE `user_info` (
  `userid` int(11) NOT NULL,
  `name` varchar(255) NOT NULL,
  UNIQUE `userid` (`userid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
再创建一个用户余额表：

CREATE TABLE `user_account` (
  `userid` int(11) NOT NULL,
  `money` bigint(20) NOT NULL,
 UNIQUE `userid` (`userid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
随便导入一些数据：

select * from user_info;
+--------+------+
| userid | name |
+--------+------+
|   1001 | x    |
|   1002 | y    |
|   1003 | z    |
|   1004 | a    |
|   1005 | b    |
|   1006 | c    |
|   1007 | d    |
|   1008 | e    |
+--------+------+
8 rows in set (0.00 sec)

select * from user_account;
+--------+-------+
| userid | money |
+--------+-------+
|   1001 |    22 |
|   1002 |    30 |
|   1003 |     8 |
|   1009 |    11 |
+--------+-------+
4 rows in set (0.00 sec)
一共8个用户有用户名，4个用户的账户有余额。
取出userid为1003的用户姓名和余额，SQL如下：

SELECT i.name, a.money 
  FROM user_info as i 
    LEFT JOIN user_account as a 
      ON i.userid = a.userid 
        WHERE a.userid = 1003;
第一步：执行FROM子句对两张表进行笛卡尔积操作
笛卡尔积操作后会返回两张表中所有行的组合，左表user_info有8行，右表user_account有4行，生成的虚拟表vt1就是8*4=32行：

SELECT * FROM user_info as i LEFT JOIN user_account as a ON 1;
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1001 |    22 |
|   1003 | z    |   1001 |    22 |
|   1004 | a    |   1001 |    22 |
|   1005 | b    |   1001 |    22 |
|   1006 | c    |   1001 |    22 |
|   1007 | d    |   1001 |    22 |
|   1008 | e    |   1001 |    22 |
|   1001 | x    |   1002 |    30 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1002 |    30 |
|   1004 | a    |   1002 |    30 |
|   1005 | b    |   1002 |    30 |
|   1006 | c    |   1002 |    30 |
|   1007 | d    |   1002 |    30 |
|   1008 | e    |   1002 |    30 |
|   1001 | x    |   1003 |     8 |
|   1002 | y    |   1003 |     8 |
|   1003 | z    |   1003 |     8 |
|   1004 | a    |   1003 |     8 |
|   1005 | b    |   1003 |     8 |
|   1006 | c    |   1003 |     8 |
|   1007 | d    |   1003 |     8 |
|   1008 | e    |   1003 |     8 |
|   1001 | x    |   1009 |    11 |
|   1002 | y    |   1009 |    11 |
|   1003 | z    |   1009 |    11 |
|   1004 | a    |   1009 |    11 |
|   1005 | b    |   1009 |    11 |
|   1006 | c    |   1009 |    11 |
|   1007 | d    |   1009 |    11 |
|   1008 | e    |   1009 |    11 |
+--------+------+--------+-------+
32 rows in set (0.00 sec)
第二步：执行ON子句过滤掉不满足条件的行
ON i.userid = a.userid 过滤之后vt2如下：

+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+
第三步：JOIN 添加外部行
LEFT JOIN会将左表未出现在vt2的行插入进vt2，每一行的剩余字段将被填充为NULL，RIGHT JOIN同理
本例中用的是LEFT JOIN，所以会将左表user_info剩下的行都添上 生成表vt3：

+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
|   1004 | a    |   NULL |  NULL |
|   1005 | b    |   NULL |  NULL |
|   1006 | c    |   NULL |  NULL |
|   1007 | d    |   NULL |  NULL |
|   1008 | e    |   NULL |  NULL |
+--------+------+--------+-------+
第四步：WHERE条件过滤
WHERE a.userid = 1003 生成表vt4：

+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+
第五步：SELECT
SELECT i.name, a.money 生成vt5：

+------+-------+
| name | money |
+------+-------+
| z    |     8 |
+------+-------+
虚拟表vt5作为最终结果返回给客户端

介绍完联表的过程之后，我们看看常用JOIN的区别

4 INNER/LEFT/RIGHT/FULL JOIN的区别
INNER JOIN...ON...: 返回 左右表互相匹配的所有行（因为只执行上文的第二步ON过滤，不执行第三步 添加外部行）
LEFT JOIN...ON...: 返回左表的所有行，若某些行在右表里没有相对应的匹配行，则将右表的列在新表中置为NULL
RIGHT JOIN...ON...: 返回右表的所有行，若某些行在左表里没有相对应的匹配行，则将左表的列在新表中置为NULL
INNER JOIN
拿上文的第三步添加外部行来举例，若LEFT JOIN替换成INNER JOIN，则会跳过这一步，生成的表vt3与vt2一模一样：

+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+
RIGHT JOIN
若LEFT JOIN替换成RIGHT JOIN，则生成的表vt3如下：

+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
|   NULL | NULL |   1009 |    11 |
+--------+------+--------+-------+
因为user_account（右表）里存在userid=1009这一行，而user_info（左表）里却找不到这一行的记录，所以会在第三步插入以下一行：

| NULL | NULL | 1009 | 11 |
FULL JOIN
上文引用的文章中提到了标准SQL定义的FULL JOIN，这在mysql里是不支持的，不过我们可以通过LEFT JOIN + UNION + RIGHT JOIN 来实现FULL JOIN：

SELECT * 
  FROM user_info as i 
    RIGHT JOIN user_account as a 
      ON a.userid=i.userid
union 
SELECT * 
  FROM user_info as i 
    LEFT JOIN user_account as a 
      ON a.userid=i.userid;
他会返回如下结果：

+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
|   NULL | NULL |   1009 |    11 |
|   1004 | a    |   NULL |  NULL |
|   1005 | b    |   NULL |  NULL |
|   1006 | c    |   NULL |  NULL |
|   1007 | d    |   NULL |  NULL |
|   1008 | e    |   NULL |  NULL |
+--------+------+--------+-------+
ps：其实我们从语义上就能看出LEFT JOIN和RIGHT JOIN没什么差别，两者的结果差异取决于左右表的放置顺序，以下内容摘自mysql官方文档：

RIGHT JOIN works analogously to LEFT JOIN. To keep code portable across databases, it is recommended that you use LEFT JOIN instead of RIGHT JOIN.
所以当你纠结使用LEFT JOIN还是RIGHT JOIN时，尽可能只使用LEFT JOIN吧

5 ON和WHERE的区别
上文把JOIN的执行顺序了解清楚之后，ON和WHERE的区别也就很好理解了。
举例说明:

SELECT * 
  FROM user_info as i
    LEFT JOIN user_account as a
      ON i.userid = a.userid and i.userid = 1003;
SELECT * 
  FROM user_info as i
    LEFT JOIN user_account as a
      ON i.userid = a.userid where i.userid = 1003;
第一种情况LEFT JOIN在执行完第二步ON子句后，筛选出满足i.userid = a.userid and i.userid = 1003的行，生成表vt2，然后执行第三步JOIN子句，将外部行添加进虚拟表生成vt3即最终结果：

vt2:
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+
vt3:
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   NULL |  NULL |
|   1002 | y    |   NULL |  NULL |
|   1003 | z    |   1003 |     8 |
|   1004 | a    |   NULL |  NULL |
|   1005 | b    |   NULL |  NULL |
|   1006 | c    |   NULL |  NULL |
|   1007 | d    |   NULL |  NULL |
|   1008 | e    |   NULL |  NULL |
+--------+------+--------+-------+
而第二种情况LEFT JOIN在执行完第二步ON子句后，筛选出满足i.userid = a.userid的行，生成表vt2；再执行第三步JOIN子句添加外部行生成表vt3；然后执行第四步WHERE子句，再对vt3表进行过滤生成vt4，得的最终结果：

vt2:
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+
vt3:
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
|   1004 | a    |   NULL |  NULL |
|   1005 | b    |   NULL |  NULL |
|   1006 | c    |   NULL |  NULL |
|   1007 | d    |   NULL |  NULL |
|   1008 | e    |   NULL |  NULL |
+--------+------+--------+-------+
vt4:
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+
如果将上例的LEFT JOIN替换成INNER JOIN，不论将条件过滤放到ON还是WHERE里，结果都是一样的，因为INNER JOIN不会执行第三步添加外部行

SELECT * 
  FROM user_info as i
    INNER JOIN user_account as a
      ON i.userid = a.userid and i.userid = 1003;
SELECT * 
  FROM user_info as i
    INNER JOIN user_account as a
      ON i.userid = a.userid where i.userid = 1003;
返回结果都是:

+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+
</code></pre>
<h1 id="四-建议">四 建议</h1>
<pre><code>1.使用 join 语句，性能比强行拆成多个单表执行 SQL 语句的性能要好
2.如果使用 join 语句的话，需要让小表做驱动表。
3.给被驱动表的关联字段加上索引
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CASE WHEN用法]]></title>
        <id>https://codingheping.github.io/post/case-when-yong-fa/</id>
        <link href="https://codingheping.github.io/post/case-when-yong-fa/">
        </link>
        <updated>2020-11-10T08:56:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mysql-的case-when-的语法">Mysql 的case when 的语法:</h1>
<p>1.简单函数</p>
<pre><code>CASE [col_name] WHEN [value1] THEN [result1]…ELSE [default] END
</code></pre>
<p>2.搜索函数</p>
<pre><code>CASE WHEN [expr] THEN [result1]…ELSE [default] END
</code></pre>
<h1 id="简单函数">简单函数</h1>
<pre><code>SELECT
	NAME '英雄',
	CASE NAME
		WHEN '德莱文' THEN
			'斧子'
		WHEN '德玛西亚-盖伦' THEN
			'大宝剑'
		WHEN '暗夜猎手-VN' THEN
			'弩'
		ELSE
			'无'
	END '装备'
FROM
	user_info;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5jc2RuLm5ldC8yMDE4MDMxOTE0MjgyMDM2NT93YXRlcm1hcmsvMi90ZXh0L0x5OWliRzluTG1OelpHNHVibVYwTDNGeFh6TXdNRE00TVRFeC9mb250LzVhNkw1TDJUL2ZvbnRzaXplLzQwMC9maWxsL0kwSkJRa0ZDTUE9PS9kaXNzb2x2ZS83MA?x-oss-process=image/format,png" alt="avatar" loading="lazy"></figure>
<h1 id="搜索函数">搜索函数</h1>
<pre><code>CASE WHEN [expr] THEN [result1]…ELSE [default] END：搜索函数可以写判断，并且搜索函数只会返回第一个符合条件的值，其他case被忽略
</code></pre>
<pre><code># when 表达式中可以使用 and 连接条件
SELECT
	NAME '英雄',
	age '年龄',
	CASE
		WHEN age &lt; 18 THEN
			'少年'
		WHEN age &lt; 30 THEN
			'青年'
		WHEN age &gt;= 30
		AND age &lt; 50 THEN
			'中年'
		ELSE
			'老年'
	END '状态'
FROM
	user_info;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5jc2RuLm5ldC8yMDE4MDMxOTE0MjkxMDkzP3dhdGVybWFyay8yL3RleHQvTHk5aWJHOW5MbU56Wkc0dWJtVjBMM0Z4WHpNd01ETTRNVEV4L2ZvbnQvNWE2TDVMMlQvZm9udHNpemUvNDAwL2ZpbGwvSTBKQlFrRkNNQT09L2Rpc3NvbHZlLzcw?x-oss-process=image/format,png" alt="avatar" loading="lazy"></figure>
<h1 id="聚合函数-sum-配合-case-when-的简单函数实现多表-left-join-的行转列">聚合函数 sum 配合 case when 的简单函数实现多表 left join 的行转列</h1>
<p>注：曾经有个爱学习的路人问我，“那个sum()只是为了好看一点吗？”，left join会以左表为主，连接右表时，得到所有匹配的数据，再group by时只会保留一行数据，因此case when时要借助sum函数，保留其他列的和。如果你还是不明白的话，那就亲手实践一下，只保留left join看一下结果，再group by，看一下结果。例如下面的案例：学生表/课程表/成绩表 ，三个表left join查询每个学生所有科目的成绩，使每个学生及其各科成绩一行展示。</p>
<pre><code>SELECT
	st.stu_id '学号',
	st.stu_name '姓名',
	sum(
		CASE co.course_name
		WHEN '大学语文' THEN
			sc.scores
		ELSE
			0
		END
	) '大学语文',
	sum(
		CASE co.course_name
		WHEN '新视野英语' THEN
			sc.scores
		ELSE
			0
		END
	) '新视野英语',
	sum(
		CASE co.course_name
		WHEN '离散数学' THEN
			sc.scores
		ELSE
			0
		END
	) '离散数学',
	sum(
		CASE co.course_name
		WHEN '概率论与数理统计' THEN
			sc.scores
		ELSE
			0
		END
	) '概率论与数理统计',
	sum(
		CASE co.course_name
		WHEN '线性代数' THEN
			sc.scores
		ELSE
			0
		END
	) '线性代数',
	sum(
		CASE co.course_name
		WHEN '高等数学' THEN
			sc.scores
		ELSE
			0
		END
	) '高等数学'
FROM
	edu_student st
LEFT JOIN edu_score sc ON st.stu_id = sc.stu_id
LEFT JOIN edu_courses co ON co.course_no = sc.course_no
GROUP BY
	st.stu_id
ORDER BY
	NULL;

</code></pre>
<figure data-type="image" tabindex="3"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5jc2RuLm5ldC8yMDE4MDMxOTE1MDg0MTkwNT93YXRlcm1hcmsvMi90ZXh0L0x5OWliRzluTG1OelpHNHVibVYwTDNGeFh6TXdNRE00TVRFeC9mb250LzVhNkw1TDJUL2ZvbnRzaXplLzQwMC9maWxsL0kwSkJRa0ZDTUE9PS9kaXNzb2x2ZS83MA?x-oss-process=image/format,png" alt="avatar" loading="lazy"></figure>
<h2 id="测试数据">测试数据</h2>
<pre><code>-- 创建表  学生表
CREATE TABLE `edu_student` (
	`stu_id` VARCHAR (16) NOT NULL COMMENT '学号',
	`stu_name` VARCHAR (20) NOT NULL COMMENT '学生姓名',
	PRIMARY KEY (`stu_id`)
) COMMENT = '学生表' ENGINE = INNODB;

-- 课程表 
CREATE TABLE `edu_courses` (
	`course_no` VARCHAR (20) NOT NULL COMMENT '课程编号',
	`course_name` VARCHAR (100) NOT NULL COMMENT '课程名称',
	PRIMARY KEY (`course_no`)
) COMMENT = '课程表' ENGINE = INNODB;

-- 成绩表
CREATE TABLE `edu_score` (
	`stu_id` VARCHAR (16) NOT NULL COMMENT '学号',
	`course_no` VARCHAR (20) NOT NULL COMMENT '课程编号',
	`scores` FLOAT NULL DEFAULT NULL COMMENT '得分',
	PRIMARY KEY (`stu_id`, `course_no`)
) COMMENT = '成绩表' ENGINE = INNODB;

-- 插入数据

-- 学生表数据

INSERT INTO edu_student (stu_id, stu_name)
VALUES
	('1001', '盲僧'),
	('1002', '赵信'),
	('1003', '皇子'),
	('1004', '寒冰'),
	('1005', '蛮王'),
	('1006', '狐狸');

-- 课程表数据 
INSERT INTO edu_courses (course_no, course_name)
VALUES
	('C001', '大学语文'),
	('C002', '新视野英语'),
	('C003', '离散数学'),
	(
		'C004',
		'概率论与数理统计'
	),
	('C005', '线性代数'),
	('C006', '高等数学');

-- 成绩表数据
INSERT INTO edu_score (stu_id, course_no, scores)
VALUES
	('1001', 'C001', 67),	('1002', 'C001', 68),	('1003', 'C001', 69),	('1004', 'C001', 70),	('1005', 'C001', 71),
	('1006', 'C001', 72),	('1001', 'C002', 87),	('1002', 'C002', 88),	('1003', 'C002', 89),	('1004', 'C002', 90),
	('1005', 'C002', 91),	('1006', 'C002', 92),	('1001', 'C003', 83),	('1002', 'C003', 84),	('1003', 'C003', 85),
	('1004', 'C003', 86),	('1005', 'C003', 87),	('1006', 'C003', 88),	('1001', 'C004', 88),	('1002', 'C004', 89),
	('1003', 'C004', 90),	('1004', 'C004', 91),	('1005', 'C004', 92),	('1006', 'C004', 93),	('1001', 'C005', 77),
	('1002', 'C005', 78),	('1003', 'C005', 79);

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue.socket-io连接hyperf.socket-io服务]]></title>
        <id>https://codingheping.github.io/post/vuesocket-io-lian-jie-hyperfsocket-io-fu-wu/</id>
        <link href="https://codingheping.github.io/post/vuesocket-io-lian-jie-hyperfsocket-io-fu-wu/">
        </link>
        <updated>2020-11-08T15:27:14.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://codingheping.github.io/post-images/1604849329083.jpg" alt="" loading="lazy"></figure>
<p>Last Edited By: he peter<br>
修改时间: Nov 8, 2020 11:25 PM<br>
创建人: he peter<br>
标签: sokcet.io,hyperf<br>
项目创建时间: Nov 8, 2020 11:16 PM</p>
<h2 id="1mainjs引入socket-io相关文件">1.main.js引入socket-io相关文件</h2>
<pre><code class="language-jsx">import VueSocketIO from 'vue-socket.io';

import SocketIO from 'socket.io-client';
</code></pre>
<h2 id="2初始化socket-io">2.初始化socket-io</h2>
<pre><code class="language-jsx">const token = `${getToken()}`

const socketInstance = SocketIO(process.env.WEB_SOCKET_URL, {
  transports: ['websocket','polling'],
  transportOptions: {
    polling: {
      extraHeaders: {
        Authorization: token
      }
    }
  },
  query:{
    token:token
  }
});

this.socket = new VueSocketIO({
  debug: true,
  connection: socketInstance
})
// Websocket 连接成功回调方法
this.socket.io.on('connect', () =&gt; {
  store.commit('UPDATE_SOCKET_STATUS', true);
})
// Websocket 断开连接回调方法
this.socket.io.on('disconnect', () =&gt; {
  store.commit('UPDATE_SOCKET_STATUS', false);
})
// Websocket 断开连接回调方法
this.socket.io.on('reconnect', () =&gt; {
  store.commit('UPDATE_SOCKET_STATUS', true);
})
Vue.use(this.socket)
</code></pre>
<h2 id="3组件中使用">3.组件中使用</h2>
<pre><code class="language-jsx">sockets: {
  // 三个默认方法
  // 链接成功
  connect () {
    console.log('socket connected')
  },
  // 链接失败
  disconnect () {
    console.log('socket disconnect')
  },
  // 重新连接
  reconnect () {
    console.log('socket reconnect')
  },
  // 第二种：监听、接收消息方法
  event (data) {
    console.log(data, 'TEAM_NOTICE，推送的消息')
  }
},
</code></pre>
<h2 id="4发送socket-io消息">4.发送socket-io消息</h2>
<pre><code class="language-jsx">mounted() {
  this.scrollEvent();
  // 第一种：监听，接收消息
  this.$socket.emit('event', {
    projectId: '88',
    theme: 'getUserInfo',
    time: 10000,
  });
},
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hyperf搭建socket-io服务]]></title>
        <id>https://codingheping.github.io/post/hyperf-da-jian-socket-io-fu-wu/</id>
        <link href="https://codingheping.github.io/post/hyperf-da-jian-socket-io-fu-wu/">
        </link>
        <updated>2020-11-04T15:37:22.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://codingheping.github.io/post-images/1604505686106.jpg" alt="" loading="lazy"><br>
Last Edited By: he peter<br>
修改时间: Nov 4, 2020 11:35 PM<br>
创建人: he peter<br>
标签: Hyperf<br>
项目创建时间: Nov 4, 2020 11:23 PM</p>
<h2 id="背景">背景</h2>
<p>自己一直想做一个分布式的IM,开始想的就是利用hyperf搭建个rpc服务做个消息代理,写了很久转过头来看了看hyperf的socket-io服务,发现他底层提供的RedisAdpater和RedisNsqAdpater提供处理分布式关系建立,然后利用redis的广播(pub,sub)或者NSQ建立一个Topic,每个socket服务单独建立一个channel，然后获取全部channel，给全部channel消费.</p>
<h3 id="1安装socket-io">1.安装socket-io</h3>
<pre><code class="language-bash">composer require hyperf/socketio-server
</code></pre>
<h2 id="2配置server">2.配置server</h2>
<pre><code class="language-php">// config/autoload/server.php
[
    'name' =&gt; 'socket-io',
    'type' =&gt; Server::SERVER_WEBSOCKET,
    'host' =&gt; '0.0.0.0',
    'port' =&gt; 9502,
    'sock_type' =&gt; SWOOLE_SOCK_TCP,
    'callbacks' =&gt; [
        SwooleEvent::ON_HAND_SHAKE =&gt; [Hyperf\WebSocketServer\Server::class, 'onHandShake'],
        SwooleEvent::ON_MESSAGE =&gt; [Hyperf\WebSocketServer\Server::class, 'onMessage'],
        SwooleEvent::ON_CLOSE =&gt; [Hyperf\WebSocketServer\Server::class, 'onClose'],
    ],
],
</code></pre>
<h3 id="3搭建服务端">3.搭建服务端</h3>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace App\Controller;

use Hyperf\SocketIOServer\Annotation\Event;
use Hyperf\SocketIOServer\Annotation\SocketIONamespace;
use Hyperf\SocketIOServer\BaseNamespace;
use Hyperf\SocketIOServer\Socket;
use Hyperf\Utils\Codec\Json;

/**
 * @SocketIONamespace(&quot;/&quot;)
 */
class WebSocketController extends BaseNamespace
{
    /**
     * @Event(&quot;event&quot;)
     * @param string $data
     */
    public function onEvent(Socket $socket, $data)
    {
        // 应答
        return 'Event Received: ' . $data;
    }

    /**
     * @Event(&quot;join-room&quot;)
     * @param string $data
     */
    public function onJoinRoom(Socket $socket, $data)
    {
        // 将当前用户加入房间
        $socket-&gt;join($data);
        // 向房间内其他用户推送（不含当前用户）
        $socket-&gt;to($data)-&gt;emit('event', $socket-&gt;getSid() . &quot;has joined {$data}&quot;);
        // 向房间内所有人广播（含当前用户）
        $this-&gt;emit('event', 'There are ' . count($socket-&gt;getAdapter()-&gt;clients($data)) . &quot; players in {$data}&quot;);
    }

    /**
     * @Event(&quot;say&quot;)
     * @param string $data
     */
    public function onSay(Socket $socket, $data)
    {
        $data = Json::decode($data);
        $socket-&gt;to($data['room'])-&gt;emit('event', $socket-&gt;getSid() . &quot; say: {$data['message']}&quot;);
    }
}

</code></pre>
<h2 id="4配置房间适配器利用redisnsqadapter处理分布式">4.配置房间适配器,利用RedisNsqAdapter处理分布式</h2>
<pre><code class="language-php">&lt;?php

declare(strict_types = 1);

/**
 * This file is part of Hyperf.
 *
 * @link     https://www.hyperf.io
 * @document https://hyperf.wiki
 * @contact  group@hyperf.io
 * @license  https://github.com/hyperf/hyperf/blob/master/LICENSE
 */

use Hyperf\SocketIOServer\Room\AdapterInterface;
use Hyperf\SocketIOServer\Room\RedisNsqAdapter;
use Hyperf\SocketIOServer\SocketIO;
use App\Kernel\SocketIO as KernelSocketIO;
use Hyperf\JsonRpc\JsonRpcPoolTransporter;
use Hyperf\JsonRpc\JsonRpcTransporter;
use Hyperf\Utils\Serializer\SerializerFactory;
use Hyperf\Utils\Serializer\Serializer;

return [
    AdapterInterface::class                    =&gt; RedisNsqAdapter::class,
    SocketIO::class                            =&gt; KernelSocketIO::class,
    JsonRpcTransporter::class                  =&gt; JsonRpcPoolTransporter::class,
    Hyperf\Contract\NormalizerInterface::class =&gt; new SerializerFactory(Serializer::class),
];
</code></pre>
<h2 id="5重写socket-io主要用于用户上线通知下线通知">5.重写socket-io(主要用于用户上线通知,下线通知)</h2>
<pre><code class="language-php">&lt;?php
declare(strict_types = 1);

namespace App\Kernel;

use App\JsonRpc\Contract\InterfaceUserService;
use App\Log;
use Hyperf\Redis\RedisFactory;
use Hyperf\WebSocketServer\Context as WsContext;
use Phper666\JWTAuth\Exception\TokenValidException;
use Swoole\Http\Request;
use Hyperf\Di\Annotation\Inject;

class SocketIO extends \Hyperf\SocketIOServer\SocketIO
{
    protected $pingTimeout = 2000;

    protected $pingInterval = 10000; //心跳间隔6秒

    protected $clientCallbackTimeout = 2000;

    public const HASH_UID_TO_FD_PREFIX = 'hash.socket_user';

    /**
     * @Inject
     * @var \Phper666\JWTAuth\JWT
     */
    protected $jwt;

    /**
     * @Inject()
     * @var \App\Service\UserService
     */
    protected $userService;

    /**
     * @Inject()
     * @var \App\Service\UserFriendService
     */
    protected $userFriendService;

    /**
     * @param \Swoole\Http\Response|\Swoole\WebSocket\Server $server
     * @param \Swoole\Http\Request                           $request
     *
     * @throws \Throwable
     */
    public function onOpen($server, Request $request) : void
    {
        try {
            $isValidToken = false;
            $token        = $request-&gt;get['token'] ?? '';
            if (strlen($token) &gt; 0) {
                if (di(InterfaceUserService::class)-&gt;checkToken($token)) {
                    $isValidToken = true;
                }
            }
            if (!$isValidToken) {
                throw new TokenValidException('Token authentication does not pass', 401);
            }
        } catch (\Throwable $throwable) {
            $this-&gt;stdoutLogger-&gt;error(sprintf('[%s] [%s]', $throwable-&gt;getMessage(), $throwable-&gt;getCode()));
            $server-&gt;close($request-&gt;fd);
            return;
        }

        $userData = di(InterfaceUserService::class)-&gt;decodeToken($token);
        $uid      = $userData['cloud_uid'] ?? 0;
        $rpcUser  = di(InterfaceUserService::class);
        $user     = $rpcUser-&gt;get($uid);
        //TODO 建立json-rpc客户端获取用户详细信息
        WsContext::set('user', array_merge(
            ['user' =&gt; $user],
            ['sid' =&gt; $this-&gt;sidProvider-&gt;getSid($request-&gt;fd)]));
        //判断用户是否在其它地方登录
        $redis    = di(RedisFactory::class)-&gt;get(env('CLOUD_REDIS'));
        $isOnline = $sid = $redis-&gt;hGet(self::HASH_UID_TO_FD_PREFIX, (string)$uid);
        $redis-&gt;multi();
        if ($sid) {
            //解除之前的关系
            $redis-&gt;hDel(self::HASH_UID_TO_FD_PREFIX, (string)$uid);
            $this-&gt;to($sid)-&gt;emit('leave', '您的账号在其他地方登录,请注意是否是账号信息被泄漏,请及时更改密码!');
        }
        unset($sid);
        $sid = $this-&gt;sidProvider-&gt;getSid($request-&gt;fd);
        // 绑定用户与fd该功能
        $redis-&gt;hSet(self::HASH_UID_TO_FD_PREFIX, (string)$uid, $sid);
        $redis-&gt;exec();

        // 绑定聊天群
        $groups = $this-&gt;userService-&gt;getUserGroupIds($uid);
        if ($groups) {
            foreach ($groups as $group) {
                $this-&gt;getAdapter()-&gt;add(
                    $this-&gt;sidProvider-&gt;getSid($request-&gt;fd),
                    'room' . (string)$group);
            }
        }
        if (!$isOnline) {
            //获取所有好友的用户ID
            $uids       = $this-&gt;userFriendService-&gt;getFriends($uid);
            $friendSids = [];//所有好友的客户端socketid(sid)
            foreach ($uids as $friend) {
                $friendSids = array_push($friendSids, $redis-&gt;hGet(self::HASH_UID_TO_FD_PREFIX, (string)$friend));
            }
            //推送好友上线通知
            if ($friendSids) {
                $this-&gt;to($sid)-&gt;emit('login_notify', $friendSids, ['user_id' =&gt; $uid, 'status' =&gt; 1, 'notify' =&gt; '好友上线通知...']);
            }
        }
        // 绑定聊天群
        parent::onOpen($server, $request);
    }

    /**
     * @param \Swoole\Http\Response|\Swoole\Server $server
     * @param int                                  $fd
     * @param int                                  $reactorId
     *
     * @throws \Throwable
     */
    public function onClose($server, int $fd, int $reactorId) : void
    {
        /**
         * @var array $user
         */
        $user = WsContext::get('user');
        // 获取客户端对应的用户ID
        // 清除用户绑定信息
        $redis = di(RedisFactory::class)-&gt;get(env('CLOUD_REDIS'));
        $redis-&gt;hDel(self::HASH_UID_TO_FD_PREFIX, (string)$user['user']['id']);
        // 将fd 退出所有聊天室
        $this-&gt;getAdapter()-&gt;del($user['sid']);
        WsContext::destroy('user');
        //获取所有好友的用户ID
        $uids       = $this-&gt;userFriendService-&gt;getFriends($user['user']['id']);
        $friendSids = [];//所有好友的客户端socketid(sid)
        foreach ($uids as $friend) {
            $friendSids = array_push($friendSids, $redis-&gt;hGet(self::HASH_UID_TO_FD_PREFIX, (string)$friend));
        }
        //推送好友下线通知
        if ($friendSids) {
            $this-&gt;to($user['sid'])-&gt;emit('login_notify', $friendSids, [
                'user_id' =&gt; $user['id'],
                'status'  =&gt; 0,
                'notify'  =&gt; '好友离线通知...'
            ]);
        }
        // 判断用户是否多平台登录
        parent::onClose($server, $fd, $reactorId);
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用redis存储websocket或tcp的fd功能和聊天室内的fd]]></title>
        <id>https://codingheping.github.io/post/li-yong-redis-cun-chu-websocket-huo-tcp-de-fd-gong-neng-he-liao-tian-shi-nei-de-fd/</id>
        <link href="https://codingheping.github.io/post/li-yong-redis-cun-chu-websocket-huo-tcp-de-fd-gong-neng-he-liao-tian-shi-nei-de-fd/">
        </link>
        <updated>2020-11-04T09:33:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="利用redis存储websocket或tcp的fd功能和聊天室内的fd">利用redis存储websocket或tcp的fd功能和聊天室内的fd</h1>
<p>Last Edited By: he peter<br>
修改时间: Nov 4, 2020 5:31 PM<br>
创建人: he peter<br>
标签: websocket<br>
项目创建时间: Oct 21, 2020 10:08 AM</p>
<h1 id="利用redis的hash类型存储fd">利用redis的hash类型存储fd</h1>
<pre><code class="language-php">$redis = di(RedisFactory::class)-&gt;get(env('CLOUD_REDIS'));
//bind key to fd
$redis-&gt;hSet(self::HASH_KEY_TO_FD_PREFIX, $key, $fd);
</code></pre>
<h1 id="利用set无序集合存储聊天室内的fd">利用set无序集合存储聊天室内的fd</h1>
<pre><code class="language-php">//add fd to room
$redis-&gt;sAdd(sprintf('%s.%s', self::SET_ROOM_FD_PREFIX, $roomId), $fd);
</code></pre>
]]></content>
    </entry>
</feed>